<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 2 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: <a href="https://cal-cs184.github.io/hw-webpages-su25-Carlyndaxg/">cal-cs184.github.io/hw-webpages-su25-Carlyndaxg/</a>

		<br>
		
		Link to GitHub repository: <a href="https://github.com/cal-cs184/hw2-meshedit-cgao">github.com/cal-cs184/hw2-meshedit-cgao</a>

		<figure>
			<img src="teapot.png" alt="Teapot" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>

		<h2>Section I: Bezier Curves and Surfaces</h2>

		<h3>Part 1: Bezier curves with 1D de Casteljau subdivision</h3>
		De Casterljau's algorithm is a recursive algorithm used to evaluate points on a Bezier curve at a given parameter t, which falls between
		0 and 1. The algorithm linearly intepolates between consecutive points at the parameter t to produce n new points, and this process repeats
		recursively on the new set of points until only one point remains. This final point lies on the Bezier curve that corresponds to 
		parameter t. My implementation of the recursive subdivision step takes a vector of 2D control points and returns the new points
		after performing one level of interpolation. This was done by computing the weighted average for each pair of consecutive points, 
		then storing it in a new vetor, which represents the next level of control points. 

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="part1/part1-7.png" width="400px"/>
				  <figcaption>My Bezier curve with 6 control points</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part1/part1-8.png" width="400px"/>
				  <figcaption>Completed Bezier curve</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="part1/part1-6.png" width="400px"/>
				  <figcaption>First level</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part1/part1-5.png" width="400px"/>
				  <figcaption>Second level</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="part1/part1-4.png" width="400px"/>
				  <figcaption>Third level</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part1/part1-3.png" width="400px"/>
				  <figcaption>Fourth level</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="part1/part1-2.png" width="400px"/>
				  <figcaption>Final point</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part1/part1-9.png" width="400px"/>
				  <figcaption>Modified parameter t</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="part1/part1-1.png" width="400px"/>
				  <figcaption>Slightly different Bezier curve</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part1/part1-10.png" width="400px"/>
				  <figcaption>Another slightly different Bezier curve with modified t</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h3>Part 2: Bezier surfaces with separable 1D de Casteljau</h3>
		De Casteljau's algorithm can be extended to Bezier surfaces by evaluating the point on the surface at u, v. This is done by 
		first fixing u and applying the 1D de Casteljau's algorithm across each row of control points. Then we would fix v and apply the 
		1D de Casteljau's algorithm across the column of points obtained by fixing u. This essentially reduces the 2D surface to a series of 
		1D interpolations. I implemented de Casteljau's to evaluate Bezier surfaces by first performing one iteration of linear interpolation
		between each pair of adjacent control points for a given parameter t in evaluateStep. Then in evaluate1D, I recursively applied evaluateStep
		until only one point remains, and finally I evaluate each row and column with evaluate(u, v) to get the final surface point.

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="part2/part2-1.png" width="400px"/>
				  <figcaption>Edge data</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part2/part2-2.png" width="400px"/>
				  <figcaption>Face data</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>

		<h3>Part 3: Area-weighted vertex normals</h3>
		I implemented the area-weighted vertex normals by iterating over the surrounding faces using the half edge data structure for each vertex.
		For each triangle face adjacent to the vertex, I took the cross product of two edge vectors then weighed each by the area of the 
		corresponding triangle. I then normalized the resulting vector, ultimately resulting in smoother and more realistic shading. 

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="part3/part3-1.png" width="400px"/>
				  <figcaption>Flat shading</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part3/part3-2.png" width="400px"/>
				  <figcaption>Phong shading</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h3>Part 4: Edge flip</h3>
		To implement edge flipping, I first checked if the edge was a boundary edge, and if it was, I returned the original edge unflipped.
		For internal edges, I took the size halfedges and their corresponding vertices, faces, and edges, and reassigned the next, twin, vertex, 
		edge, and face pointers setNeighbors. Then after reconnecting the halfedges in the new edge direction, I updated the halfedge pointers 
		for the four vertices and adjacent faces. It was tricky for me to get the setNeighbors arguments in the right order. I figured this out by
		using print statements so I could see which halfedge each one pointed to before and after flipping. 

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="part3/part3-1.png" width="400px"/>
				  <figcaption>Flat shading, no flips</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part4/part4-5.png" width="400px"/>
				  <figcaption>Flat shading, with flips</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="part3/part3-2.png" width="400px"/>
				  <figcaption>Phong shading, no flips</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part4/part4-6.png" width="400px"/>
				  <figcaption>Phong shading, with flips</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h3>Part 5: Edge split</h3>
		To implement edge splitting, I first listed out all of the old relationships before splitting and did a boundary check. If the edge is a boundary edge, I returned without splitting. Next I 
		created a new vertex, v4, positioned at the very middle. Then I added new halfedges, edges, and faces to maintain a valid mesh after
		the split, and reassigned next, twin, vertex, edge, and face pointers. 


		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="part3/part3-1.png" width="400px"/>
				  <figcaption>Flat shading, no flipping or splitting</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part5/part5-1.png" width="400px"/>
				  <figcaption>Flat shading, with splitting</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="part3/part3-1.png" width="400px"/>
				  <figcaption>Flat shading, no flipping or splitting</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part5/part5-3.png" width="400px"/>
				  <figcaption>Flat shading, with flipping and splitting</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h3>Part 6: Loop subdivision for mesh upsampling</h3>
		To implement loop subdivision, I first computed new positions for the old and new vertices that would be created at edge midpoints. Then I split
		every edge in the mesh once to create new vertices at the midpoints, and flipped all the new edges connecting old and new vertices. 
		After subdivision, I updated the position of each vertex in the new mesh, which smooths the geometry based on the weighted averages from the 
		original positions. 

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="part6/part6-1.png" width="400px"/>
				  <figcaption>Before loop subdivision</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part6/part6-2.png" width="400px"/>
				  <figcaption>After subdividing once</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>(Optional) Section III: Potential Extra Credit - Art Competition: Model something Creative</h2>

		</div>
	</body>
</html>